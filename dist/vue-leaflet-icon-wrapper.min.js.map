{"version":3,"file":"vue-leaflet-icon-wrapper.min.js","sources":["../node_modules/arrive/src/arrive.js","../src/utils/uuid.js","../node_modules/vue-runtime-helpers/dist/index.mjs","../src/index.js"],"sourcesContent":["/*globals jQuery,Window,HTMLElement,HTMLDocument,HTMLCollection,NodeList,MutationObserver */\n/*exported Arrive*/\n/*jshint latedef:false */\n\n/*\n * arrive.js\n * v2.4.1\n * https://github.com/uzairfarooq/arrive\n * MIT licensed\n *\n * Copyright (c) 2014-2017 Uzair Farooq\n */\nvar Arrive = (function(window, $, undefined) {\n\n  \"use strict\";\n\n  if(!window.MutationObserver || typeof HTMLElement === 'undefined'){\n    return; //for unsupported browsers\n  }\n\n  var arriveUniqueId = 0;\n\n  var utils = (function() {\n    var matches = HTMLElement.prototype.matches || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector\n                  || HTMLElement.prototype.msMatchesSelector;\n\n    return {\n      matchesSelector: function(elem, selector) {\n        return elem instanceof HTMLElement && matches.call(elem, selector);\n      },\n      // to enable function overloading - By John Resig (MIT Licensed)\n      addMethod: function (object, name, fn) {\n        var old = object[ name ];\n        object[ name ] = function(){\n          if ( fn.length == arguments.length ) {\n            return fn.apply( this, arguments );\n          }\n          else if ( typeof old == 'function' ) {\n            return old.apply( this, arguments );\n          }\n        };\n      },\n      callCallbacks: function(callbacksToBeCalled, registrationData) {\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // as onlyOnce param is true, make sure we fire the event for only one item\n          callbacksToBeCalled = [callbacksToBeCalled[0]];\n        }\n\n        for (var i = 0, cb; (cb = callbacksToBeCalled[i]); i++) {\n          if (cb && cb.callback) {\n            cb.callback.call(cb.elem, cb.elem);\n          }\n        }\n\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // unbind event after first callback as onceOnly is true.\n          registrationData.me.unbindEventWithSelectorAndCallback.call(\n            registrationData.target, registrationData.selector, registrationData.callback);\n        }\n      },\n      // traverse through all descendants of a node to check if event should be fired for any descendant\n      checkChildNodesRecursively: function(nodes, registrationData, matchFunc, callbacksToBeCalled) {\n        // check each new node if it matches the selector\n        for (var i=0, node; (node = nodes[i]); i++) {\n          if (matchFunc(node, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: node });\n          }\n\n          if (node.childNodes.length > 0) {\n            utils.checkChildNodesRecursively(node.childNodes, registrationData, matchFunc, callbacksToBeCalled);\n          }\n        }\n      },\n      mergeArrays: function(firstArr, secondArr){\n        // Overwrites default options with user-defined options.\n        var options = {},\n            attrName;\n        for (attrName in firstArr) {\n          if (firstArr.hasOwnProperty(attrName)) {\n            options[attrName] = firstArr[attrName];\n          }\n        }\n        for (attrName in secondArr) {\n          if (secondArr.hasOwnProperty(attrName)) {\n            options[attrName] = secondArr[attrName];\n          }\n        }\n        return options;\n      },\n      toElementsArray: function (elements) {\n        // check if object is an array (or array like object)\n        // Note: window object has .length property but it's not array of elements so don't consider it an array\n        if (typeof elements !== \"undefined\" && (typeof elements.length !== \"number\" || elements === window)) {\n          elements = [elements];\n        }\n        return elements;\n      }\n    };\n  })();\n\n\n  // Class to maintain state of all registered events of a single type\n  var EventsBucket = (function() {\n    var EventsBucket = function() {\n      // holds all the events\n\n      this._eventsBucket    = [];\n      // function to be called while adding an event, the function should do the event initialization/registration\n      this._beforeAdding    = null;\n      // function to be called while removing an event, the function should do the event destruction\n      this._beforeRemoving  = null;\n    };\n\n    EventsBucket.prototype.addEvent = function(target, selector, options, callback) {\n      var newEvent = {\n        target:             target,\n        selector:           selector,\n        options:            options,\n        callback:           callback,\n        firedElems:         []\n      };\n\n      if (this._beforeAdding) {\n        this._beforeAdding(newEvent);\n      }\n\n      this._eventsBucket.push(newEvent);\n      return newEvent;\n    };\n\n    EventsBucket.prototype.removeEvent = function(compareFunction) {\n      for (var i=this._eventsBucket.length - 1, registeredEvent; (registeredEvent = this._eventsBucket[i]); i--) {\n        if (compareFunction(registeredEvent)) {\n          if (this._beforeRemoving) {\n              this._beforeRemoving(registeredEvent);\n          }\n\n          // mark callback as null so that even if an event mutation was already triggered it does not call callback\n          var removedEvents = this._eventsBucket.splice(i, 1);\n          if (removedEvents && removedEvents.length) {\n            removedEvents[0].callback = null;\n          }\n        }\n      }\n    };\n\n    EventsBucket.prototype.beforeAdding = function(beforeAdding) {\n      this._beforeAdding = beforeAdding;\n    };\n\n    EventsBucket.prototype.beforeRemoving = function(beforeRemoving) {\n      this._beforeRemoving = beforeRemoving;\n    };\n\n    return EventsBucket;\n  })();\n\n\n  /**\n   * @constructor\n   * General class for binding/unbinding arrive and leave events\n   */\n  var MutationEvents = function(getObserverConfig, onMutation) {\n    var eventsBucket    = new EventsBucket(),\n        me              = this;\n\n    var defaultOptions = {\n      fireOnAttributesModification: false\n    };\n\n    // actual event registration before adding it to bucket\n    eventsBucket.beforeAdding(function(registrationData) {\n      var\n        target    = registrationData.target,\n        observer;\n\n      // mutation observer does not work on window or document\n      if (target === window.document || target === window) {\n        target = document.getElementsByTagName(\"html\")[0];\n      }\n\n      // Create an observer instance\n      observer = new MutationObserver(function(e) {\n        onMutation.call(this, e, registrationData);\n      });\n\n      var config = getObserverConfig(registrationData.options);\n\n      observer.observe(target, config);\n\n      registrationData.observer = observer;\n      registrationData.me = me;\n    });\n\n    // cleanup/unregister before removing an event\n    eventsBucket.beforeRemoving(function (eventData) {\n      eventData.observer.disconnect();\n    });\n\n    this.bindEvent = function(selector, options, callback) {\n      options = utils.mergeArrays(defaultOptions, options);\n\n      var elements = utils.toElementsArray(this);\n\n      for (var i = 0; i < elements.length; i++) {\n        eventsBucket.addEvent(elements[i], selector, options, callback);\n      }\n    };\n\n    this.unbindEvent = function() {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n        for (var i = 0; i < elements.length; i++) {\n          if (this === undefined || eventObj.target === elements[i]) {\n            return true;\n          }\n        }\n        return false;\n      });\n    };\n\n    this.unbindEventWithSelectorOrCallback = function(selector) {\n      var elements = utils.toElementsArray(this),\n          callback = selector,\n          compareFunction;\n\n      if (typeof selector === \"function\") {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      else {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      eventsBucket.removeEvent(compareFunction);\n    };\n\n    this.unbindEventWithSelectorAndCallback = function(selector, callback) {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n      });\n    };\n\n    return this;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'arrive' events\n   */\n  var ArriveEvents = function() {\n    // Default options for 'arrive' event\n    var arriveDefaultOptions = {\n      fireOnAttributesModification: false,\n      onceOnly: false,\n      existing: false\n    };\n\n    function getArriveObserverConfig(options) {\n      var config = {\n        attributes: false,\n        childList: true,\n        subtree: true\n      };\n\n      if (options.fireOnAttributesModification) {\n        config.attributes = true;\n      }\n\n      return config;\n    }\n\n    function onArriveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var newNodes    = mutation.addedNodes,\n            targetNode = mutation.target,\n            callbacksToBeCalled = [],\n            node;\n\n        // If new nodes are added\n        if( newNodes !== null && newNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(newNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n        else if (mutation.type === \"attributes\") {\n          if (nodeMatchFunc(targetNode, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: targetNode });\n          }\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData, callbacksToBeCalled) {\n      // check a single node to see if it matches the selector\n      if (utils.matchesSelector(node, registrationData.selector)) {\n        if(node._id === undefined) {\n          node._id = arriveUniqueId++;\n        }\n        // make sure the arrive event is not already fired for the element\n        if (registrationData.firedElems.indexOf(node._id) == -1) {\n          registrationData.firedElems.push(node._id);\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    arriveEvents = new MutationEvents(getArriveObserverConfig, onArriveMutation);\n\n    var mutationBindEvent = arriveEvents.bindEvent;\n\n    // override bindEvent function\n    arriveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = arriveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(arriveDefaultOptions, options);\n      }\n\n      var elements = utils.toElementsArray(this);\n\n      if (options.existing) {\n        var existing = [];\n\n        for (var i = 0; i < elements.length; i++) {\n          var nodes = elements[i].querySelectorAll(selector);\n          for (var j = 0; j < nodes.length; j++) {\n            existing.push({ callback: callback, elem: nodes[j] });\n          }\n        }\n\n        // no need to bind event if the callback has to be fired only once and we have already found the element\n        if (options.onceOnly && existing.length) {\n          return callback.call(existing[0].elem, existing[0].elem);\n        }\n\n        setTimeout(utils.callCallbacks, 1, existing);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return arriveEvents;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'leave' events\n   */\n  var LeaveEvents = function() {\n    // Default options for 'leave' event\n    var leaveDefaultOptions = {};\n\n    function getLeaveObserverConfig() {\n      var config = {\n        childList: true,\n        subtree: true\n      };\n\n      return config;\n    }\n\n    function onLeaveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var removedNodes  = mutation.removedNodes,\n            callbacksToBeCalled = [];\n\n        if( removedNodes !== null && removedNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(removedNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData) {\n      return utils.matchesSelector(node, registrationData.selector);\n    }\n\n    leaveEvents = new MutationEvents(getLeaveObserverConfig, onLeaveMutation);\n\n    var mutationBindEvent = leaveEvents.bindEvent;\n\n    // override bindEvent function\n    leaveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = leaveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(leaveDefaultOptions, options);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return leaveEvents;\n  };\n\n\n  var arriveEvents = new ArriveEvents(),\n      leaveEvents  = new LeaveEvents();\n\n  function exposeUnbindApi(eventObj, exposeTo, funcName) {\n    // expose unbind function with function overriding\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEvent);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorOrCallback);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorAndCallback);\n  }\n\n  /*** expose APIs ***/\n  function exposeApi(exposeTo) {\n    exposeTo.arrive = arriveEvents.bindEvent;\n    exposeUnbindApi(arriveEvents, exposeTo, \"unbindArrive\");\n\n    exposeTo.leave = leaveEvents.bindEvent;\n    exposeUnbindApi(leaveEvents, exposeTo, \"unbindLeave\");\n  }\n\n  if ($) {\n    exposeApi($.fn);\n  }\n  exposeApi(HTMLElement.prototype);\n  exposeApi(NodeList.prototype);\n  exposeApi(HTMLCollection.prototype);\n  exposeApi(HTMLDocument.prototype);\n  exposeApi(Window.prototype);\n\n  var Arrive = {};\n  // expose functions to unbind all arrive/leave events\n  exposeUnbindApi(arriveEvents, Arrive, \"unbindAllArrive\");\n  exposeUnbindApi(leaveEvents, Arrive, \"unbindAllLeave\");\n\n  return Arrive;\n\n})(window, typeof jQuery === 'undefined' ? null : jQuery, undefined);","export const uuid = () => {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nconst isOldIE = typeof navigator !== 'undefined' &&\r\n    /msie [6-9]\\\\b/.test(navigator.userAgent.toLowerCase());\r\nfunction createInjector(context) {\r\n    return (id, style) => addStyle(id, style);\r\n}\r\nlet HEAD;\r\nconst styles = {};\r\nfunction addStyle(id, css) {\r\n    const group = isOldIE ? css.media || 'default' : id;\r\n    const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });\r\n    if (!style.ids.has(id)) {\r\n        style.ids.add(id);\r\n        let code = css.source;\r\n        if (css.map) {\r\n            // https://developer.chrome.com/devtools/docs/javascript-debugging\r\n            // this makes source maps inside style tags work properly in Chrome\r\n            code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */';\r\n            // http://stackoverflow.com/a/26603875\r\n            code +=\r\n                '\\n/*# sourceMappingURL=data:application/json;base64,' +\r\n                    btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +\r\n                    ' */';\r\n        }\r\n        if (!style.element) {\r\n            style.element = document.createElement('style');\r\n            style.element.type = 'text/css';\r\n            if (css.media)\r\n                style.element.setAttribute('media', css.media);\r\n            if (HEAD === undefined) {\r\n                HEAD = document.head || document.getElementsByTagName('head')[0];\r\n            }\r\n            HEAD.appendChild(style.element);\r\n        }\r\n        if ('styleSheet' in style.element) {\r\n            style.styles.push(code);\r\n            style.element.styleSheet.cssText = style.styles\r\n                .filter(Boolean)\r\n                .join('\\n');\r\n        }\r\n        else {\r\n            const index = style.ids.size - 1;\r\n            const textNode = document.createTextNode(code);\r\n            const nodes = style.element.childNodes;\r\n            if (nodes[index])\r\n                style.element.removeChild(nodes[index]);\r\n            if (nodes.length)\r\n                style.element.insertBefore(textNode, nodes[index]);\r\n            else\r\n                style.element.appendChild(textNode);\r\n        }\r\n    }\r\n}\n\nfunction createInjectorSSR(context) {\r\n    if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n        context = __VUE_SSR_CONTEXT__;\r\n    }\r\n    if (!context)\r\n        return () => { };\r\n    if (!('styles' in context)) {\r\n        context._styles = context._styles || {};\r\n        Object.defineProperty(context, 'styles', {\r\n            enumerable: true,\r\n            get: () => context._renderStyles(context._styles)\r\n        });\r\n        context._renderStyles = context._renderStyles || renderStyles;\r\n    }\r\n    return (id, style) => addStyle$1(id, style, context);\r\n}\r\nfunction addStyle$1(id, css, context) {\r\n    const group = process.env.NODE_ENV === 'production' ? css.media || 'default' : id;\r\n    const style = context._styles[group] || (context._styles[group] = { ids: [], css: '' });\r\n    if (!style.ids.includes(id)) {\r\n        style.media = css.media;\r\n        style.ids.push(id);\r\n        let code = css.source;\r\n        if (process.env.NODE_ENV !== 'production' && css.map) {\r\n            // https://developer.chrome.com/devtools/docs/javascript-debugging\r\n            // this makes source maps inside style tags work properly in Chrome\r\n            code += '\\n/*# sourceURL=' + css.map.sources[0] + ' */';\r\n            // http://stackoverflow.com/a/26603875\r\n            code +=\r\n                '\\n/*# sourceMappingURL=data:application/json;base64,' +\r\n                    Buffer.from(unescape(encodeURIComponent(JSON.stringify(css.map)))).toString('base64') +\r\n                    ' */';\r\n        }\r\n        style.css += code + '\\n';\r\n    }\r\n}\r\nfunction renderStyles(styles) {\r\n    let css = '';\r\n    for (const key in styles) {\r\n        const style = styles[key];\r\n        css +=\r\n            '<style data-vue-ssr-id=\"' +\r\n                Array.from(style.ids).join(' ') +\r\n                '\"' +\r\n                (style.media ? ' media=\"' + style.media + '\"' : '') +\r\n                '>' +\r\n                style.css +\r\n                '</style>';\r\n    }\r\n    return css;\r\n}\n\nfunction createInjector$1(context, shadowRoot) {\r\n    return (id, style) => addStyle$2(style, shadowRoot);\r\n}\r\nfunction createStyleElement(shadowRoot) {\r\n    var styleElement = document.createElement('style');\r\n    styleElement.type = 'text/css';\r\n    shadowRoot.appendChild(styleElement);\r\n    return styleElement;\r\n}\r\nfunction addStyle$2(css, shadowRoot) {\r\n    const styleElement = createStyleElement(shadowRoot);\r\n    if (css.media)\r\n        styleElement.setAttribute('media', css.media);\r\n    if ('styleSheet' in styleElement) {\r\n        styleElement.styleSheet.cssText = css.source;\r\n    }\r\n    else {\r\n        while (styleElement.firstChild) {\r\n            styleElement.removeChild(styleElement.firstChild);\r\n        }\r\n        styleElement.appendChild(document.createTextNode(css.source));\r\n    }\r\n}\n\nexport { normalizeComponent, createInjector, createInjectorSSR, createInjector$1 as createInjectorShadow };\n//# sourceMappingURL=index.mjs.map\n","import 'arrive'\nimport defaultWrapper from './components/defaultWrapper.vue'\n\nconst plugin = {\n\tinstall (Vue, options = {\n\t\tcomponentName: 'l-icon-wrapper'\n\t}) {\n\t\tVue.component(options.componentName, defaultWrapper)\n\t}\n}\n\n// Auto-install when vue is found (eg. in browser via <script> tag)\nlet GlobalVue = null;\nif (typeof window !== 'undefined') {\n\tGlobalVue = window.Vue;\n} else if (typeof global !== 'undefined') {\n\tGlobalVue = global.Vue;\n}\nif (GlobalVue) {\n\tGlobalVue.use(plugin);\n}\n\nexport default defaultWrapper;"],"names":["window","$","undefined","MutationObserver","HTMLElement","matches","arriveUniqueId","utils","prototype","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","matchesSelector","elem","selector","call","addMethod","object","name","fn","old","length","arguments","apply","this","callCallbacks","callbacksToBeCalled","registrationData","options","onceOnly","firedElems","cb","i","callback","me","unbindEventWithSelectorAndCallback","target","checkChildNodesRecursively","nodes","matchFunc","node","push","childNodes","mergeArrays","firstArr","secondArr","attrName","hasOwnProperty","toElementsArray","elements","EventsBucket","_eventsBucket","_beforeAdding","_beforeRemoving","addEvent","newEvent","removeEvent","compareFunction","registeredEvent","removedEvents","splice","beforeAdding","beforeRemoving","MutationEvents","getObserverConfig","onMutation","eventsBucket","defaultOptions","fireOnAttributesModification","observer","document","getElementsByTagName","e","config","observe","eventData","disconnect","bindEvent","unbindEvent","eventObj","unbindEventWithSelectorOrCallback","arriveEvents","arriveDefaultOptions","existing","nodeMatchFunc","_id","indexOf","mutationBindEvent","attributes","childList","subtree","mutations","forEach","mutation","newNodes","addedNodes","targetNode","type","querySelectorAll","j","setTimeout","leaveEvents","leaveDefaultOptions","removedNodes","exposeApi","NodeList","HTMLCollection","HTMLDocument","Window","Arrive","exposeUnbindApi","exposeTo","funcName","arrive","leave","jQuery","replace","c","r","Math","random","toString","navigator","test","userAgent","toLowerCase","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","render","staticRenderFns","_compiled","functional","_scopeId","context","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","h","beforeCreate","concat","plugin","install","Vue","componentName","component","defaultWrapper","GlobalVue","global","use"],"mappings":"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"}